# 😱 \[Chapter 4] 스트림 소개


## 1. 스트림이란 무엇잊가?

- 스트림은 자바 8 API에 추가된 기능

- 스트림을 이용하면

	- 선언형(데이터를 처리하는 임시 구현 코드 대신 질의로 표현 가능)으로 컬렉션 데이터를 처리할 수 있음

	- 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있음



### 예제

- 저칼로리의 요리명을 반환하고, 칼로리를 기준으로 요리를 정렬하는 자바 7 코드

	{% embed url="https://gist.github.com/SulimChoi/2246e6396450eb56369e619b44340cbf" %}{%endembed%}

	- 가비지 변수 `lowCaloricDishes` 사용. `lowCaloricDishes`는 컨테이너 역할만 하는 중간 변수



- 자바 8에서는 이런 세부 구현을 라이브러리 내에서 모두 처리

    {% embed url="https://gist.github.com/SulimChoi/0a9c3b4ba8f0410b65ec5b221ff5f20b" %} {%endembed%}
    
	- `stream()`을 `parallelStream()`으로 바꾸면 멀티코어 아키텍처에서 병렬로 실행 가능



### 스트림 장점

1. **선언형으로 코드를 구현할 수 있음**
	- 루프와 if 조건문 등의 제어 블록을 사용해서 어떻게 동작할지 지정할 필요 없이 '저칼로리의 요리만 선택하라' 같은 동작의 수행을 지정할 수 있음
	- 선언형 코드와 동작 파라미터화를 활용하면 변하는 요구사항에 쉽게 대응 가능
	- 기존 코드를 복사해 붙여 넣는 방식을 사용하지 않고 람다 표현식을 이용해 저칼로리 대신 고칼로리의 요리만 필터링하는 코드도 쉽게 구현 가능
2. **여러 빌딩 블록 연산을 연결해 복잡한 데이터 처리 파이프라인을 만들 수 있음**
	- 여러 연산을 파이프라인으로 연결해도 가독성과 명확성이 유지됨



> **자바 8의 스트림 API의 특징**
>
> - 선언형: 더 간결하고 가독성이 좋아짐
> - 조립할 수 있음: 유연성이 좋아짐
> - 병렬화: 성능이 좋아짐





### 앞으로 사용할 메뉴(menu) 예제

{% embed url="https://gist.github.com/SulimChoi/fb43db86b0ae9e7f0a8db1491e21806b" %} {%endembed%}



## 2. 스트림 시작하기

### 컬렉션 스트림

- 자바 8 컬렉션에는 스트림을 반환하는 stream 메서드가 추가됨

	> [스트림의 인터페이스 정의](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)



- **스트림**: 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
	- 연속된 요소: 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공
	- 소스: 데이터 제공 소스로부터 데이터를 소비. 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지됨
	- 데이터 처리 연산: 함수형 프로그래밍 언어에서 지원하는 연산과 데이터베이스와 비슷한 연산을 지원. 연산은 순차적으로 또는 병렬로 실행 가능



> **스트림의 특징**
>
> - 파이프라이닝(Pipelining): 스트림 연산끼리 연결해 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환
> - 내부 반복: 반복자를 이용해 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원





### 예제

{% embed url="https://gist.github.com/SulimChoi/e1905b7eed90e22014c5faf5821ad6e0" %} {%endembed%}

1. **요리 리스트를 포함하는 menu에 stream 메서드를 호출해 스트림을 얻음**
	- 데이터 소스: 요리 리스트(메뉴)
	- 데이터 소스는 연속된 요소를 스트림에 제공



2. **스트림에 `filter`, `map`, `limit`, `collect`로 이어지는 데이터 처리 연산을 적용**
	- `collect`를 제외한 모든 연산은 서로 파이프라인을 형성할 수 있도록 스트림을 반환
	- **`filter`**: 람다를 인수로 받아 스트림에서 특정 요소를 제외시킴
		- 예제에서는 300칼로리 이상의 요리를 선택하도록 함
	- **`map`**: 람다를 이용해 한 요소를 다른 요소로 변환하거나 정보를 추출
		- 예제에서는 메서드 참조를 전달해 각각의 요리명을 추출함
	- **`limit`**: 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림  크기를 축소함
	- **`collect`**: 다양한 변환 방법을 인수로 받아 스트림에 누적된 요소를 특정 결과로 변환
		- 예제에서는 스트림을 리스트로 변환



3. **`collect` 연산으로 파이프라인을 처리해 결과를 반환**
	- 스트림이 아닌 List를 반환
	- `collect`가 호출되기 전까지는 menu에서 무엇도 선택되지 않고 출력 결과도 없음
	- `collect`가 호출되기 전까지 메서드 호출이 저장되는 효과가 있음





# 3. 스트림과 컬렉션

- 자바의 기존 컬렉션과 새로운 스트림 모두 **연속된** 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공
	- 연속된: 순차적으로 값에 접근한다는 것을 의미



### 스트림 vs 컬렉션

- 데이터를 **언제** 계산하느냐가 컬렉션과 스트림의 가장 큰 차이

- 컬렉션은 현재 자료구조가 포함하는 **모든** 값을 메모리에 저장하는 자료구조
	- 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 함
	- 컬렉션에 요소를 추가하거나 컬렉션의 요소를 삭제할 수 있지만, 이런 연산을 수행할 때마다 컬렉션의 모든 요소를 메모리에 저장해야 하고, 컬렉션에 추가하려는 요소는 미리 계산되어야 함
- 스트림은 **요청할 때만 요소를 계산**하는 고정된 자료구조
	- 스트림에 요소를 추가하거나 스트림에서 요소를 제거할 수 없음
	- 사용자가 요청하는 값만 스트림에서 추출





### 딱 한 번만 탐색할 수 있다

- 스트림은 한 번만 탐색할 수 있음. 탐색된 스트림의 요소는 소비됨

- 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 함

	- 컬렉션처럼 반복 사용할 수 있는 데이터 소스여야만 가능한 방법. 데이터 소스가 IO 채널이라면 소스를 반복 사용할 수 없으므로 새로운 스트림을 만들 수 없음

	```java
	List<String> title = Arrays.asList("Java8", "In", "Action");
	Stream<String> s = title.stream();
	s.forEach(System.out::println);	//title의 각 단어를 출력
	s.forEach(System.out::println);	// java.lang.IllegalStateException: 스트림이 이미 소비되었거나 닫힘
	```

- **스트림은 단 한 번만 소비할 수 있음**





### 외부 반복과 내부 반복

- 컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 함
	- **외부 반복(external iteration)**: 사용자가 직접 요소를 반복하는 것
- 스트림은 **내부 반복(internal iteration)**을 사용
	- 내부 반복: 반복을 알아서 처리하고 결과 스트림 값을 어딘가에 저장해줌
	- 함수에 어떤 작업을 구행할지만 지정하면 모든 것이 알아서 처리됨
	- 내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있음
- 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택하지만 외부 반복에서는 병렬성을 스스로 관리해야 함
- 스트림은 내부 반복을 사용하므로 반복 과정을 신경쓰지 않아도 됨
	- 단, filter나 map 같이 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 함
	- 반복을 숨겨주는 대부분의 연산은 람다 표현식을 인수로 받으므로 동작 파라미터화를 활용할 수 있음





## 4. 스트림 연산

- `java.util.stream.Stream` 인터페이스는 많은 연산을 정의함

{% embed url="https://gist.github.com/SulimChoi/8d0f5c2f14c49b6d8ca0a5b29e8592f1" %} {%endembed%}

- 예제에서 연산을 두 그룹으로 구분할 수 있음
	- filter, map, limit은 서로 연결되어 파이프라인을 형성함
	- collect로 파이프라인을 실행한 다음 닫음
- 연결할 수 있는 스트림 연산을 **중간 연산(intermediate operation)**, 스트림을 닫는 연산을 **최종 연산(terminal operation)**이라고 함



> #### **중간 연산**
>
> - 다른 스트림을 반환하므로 여러 중간 연산을 연결해 질의를 만들 수 있음
> - 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않음. 중간 연산을 합친 다음 합쳐진 중간 연산을 최종 연산에서 한 번에 처리
> - 최적화 효과를 얻을 수 있음
> 	- limit 연산과 **쇼트서킷**이라 불리는 기법 덕분에 300 칼로리가 넘는 요리 중 처음 3개만 선택됨
> 	- `filter`과 `map`은 다른 연산이지만 한 과정으로 병합됨 (**루프 퓨전** 기법)



> #### **최종 연산**
>
> - 스트림 파이프라인에서 결과를 도출
> 	- List, Integer, void 등 스트림 이외의 결과가 반환됨
> 	- `forEach`는 소스의 각 요리에 람다를 적용한 다음 void를 반환하는 최종 연산





### 스트림 이용하기

> **스트림 이용 과정**
>
> - 질의를 수행할 데이터 소스
> - 스트림 파이프라인을 구성할 중간 연산 연결
> - 스트림 파이프라인을 실행하고 결과를 만들 최종 연산



- 스트림 파이프라인의 개념은 [빌더 패턴(builder pattern)](https://en.wikipedia.org/wiki/Builder_pattern)과 비슷
	- 빌더 패턴에서는 호출을 연결해서 설정을 만든 후(스트림에서의 중간 연산), 준비된 설정에 build 메서드를 호출(스트림에서의 최종 연산)



### 중간 연산

| 연산       | 형식      | 반환 형식   | 연산의 인수      | 함수 디스크립터 |
| ---------- | --------- | ----------- | ---------------- | --------------- |
| `filter`   | 중간 연산 | `Stream<T>` | `Predicate<T>`   | `T -> boolean`  |
| `map`      | 중간 연산 | `Stream<R>` | `Function<T, R>` | `T -> R`        |
| `limit`    | 중간 연산 | `Stream<T>` |                  |                 |
| `sorted`   | 중간 연산 | `Stream<T>` | `Comparator<T>`  | `(T, T) -> int` |
| `distinct` | 중간 연산 | `Stream<T>` |                  |                 |



### 최종 연산

| 연산      | 형식      | 반환 형식        | 목적                                                      |
| --------- | --------- | ---------------- | --------------------------------------------------------- |
| `forEach` | 최종 연산 | `void`           | 스트림의 각 요소를 소비하면서 람다를 적용                 |
| `count`   | 최종 연산 | `long` (generic) | 스트림의 요소 개수를 반환                                 |
| `collect` | 최종 연산 |                  | 스트림을 리듀스해서 리스트, 맵, 정수 형식의 컬렉션을 만듦 |





## 6. 마치며

- 스트림은 소스에서 추출된 연속 요소로, 데이터 처리 연산을 지원
- 스트림은 내부 반복을 지원. 내부 반복은 `filter`, `map`, `sorted` 등의 연산으로 반복을 추상화함
- 스트림에는 중간 연산과 최종 연산이 있음
	- 중간 연산은 스트림을 반환하면서 다른 연산과 연결되는 연산. 파이프라인을 구성할 수 있지만, 중간 연산으로는 어떤 결과도 생성할 수 없음
	- 스트림 파이프라인을 처리해 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라고 함
- 스트림의 요소는 요청할 때 게으르게 계산됨
